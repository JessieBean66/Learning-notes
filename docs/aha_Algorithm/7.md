### 第一节 开启‘树’之旅

树有着**不包含回路**的特点,所以被赋予了很多特性.

1. 一棵树的任意两个节点有且仅有唯一的一条路径连通。
2.


### 第二节 二叉树

满二叉树


完全二叉树 ：对典型的应用就是堆。


### 第三节 堆————神奇的优先队列

堆是什么？是一种特殊的完全二叉树，如下图：

![图](./Imgs/7_3_1.png)

二叉树的特点： 所有父节点都比子节点小【最小堆】，或者所有父节点都比子节点大【最大堆】

如果需要删除一个最小数，再插入一个新数23。假设14个数按最小堆的要求放入一个完全二叉树.

![图](./Imgs/7_3_2.png)

> 方法一
```javascript
const list = [0, 1, 2, 5, 12, 7, 17, 25, 19, 36, 99, 22, 28, 46, 92];
// 假设删除根节点，插入新数23到根节点，此时不符合最小堆的情况， 需要调整
const length = list.length-1
function siftDown (i){
  // 检查下标i的数据是否符合最小堆的规则
  let num = list[i]
  // let t = 0;
  // let flag= 1;

  // while(i*2<length && flag) {
  //   if (list[i*2] < )
  // }
  // 判断i是否有子节点
  let childLeft = list[i*2]
  let childRight = list[i*2 + 1]
  let min = Math.min(childLeft, childRight) // 该计算中如果出现过undefined比较值， 比较结果就是NaN。
  // min为NaN时 与数值比较总是false，刚好中断循环
  if (min <num) {
    let index = i*2
    if (min === childRight) {
      index++
    }
    switchList(i, index)
    siftDown(index)
  }
}
function switchList (x, y) {
  let num = list[x]
  list[x] = list[y]
  list[y] = num
}
list[1] = 23
siftDown(1)
console.log(list)
```

> 方法二：

```javascript

const list = [0, 1, 2, 5, 12, 7, 17, 25, 19, 36, 99, 22, 28, 46, 92];
// 假设删除根节点，插入新数23到根节点，此时不符合最小堆的情况， 需要调整
const length = list.length -1
function siftDown (i){
  // 检查下标i的数据是否符合最小堆的规则
  let flag= 0;

  while(i*2<length && !flag) {
    let t = i;
    if (list[i] >list[i*2]) {
      t = i*2
    }
    if (((i*2 + 1)<=length) && (list[t] >list[i*2 +1])) {
      t = i*2 +1
    }
    console.log('t', t)
    if (t !== i ) {
      switchList(i, t)
      i = t
    } else {
      flag = 1
    }
  }
}
function switchList (x, y) {
  let num = list[x]
  list[x] = list[y]
  list[y] = num
}
list[1] = 23
siftDown(1)
console.log(list)
```

如果想新增一个值，而不是删除一个值。直接再插入到末尾，再根据情况，判断元素是否需要上移。直到满足堆的特性。
假设堆的大小为N，时间复杂度就是O(logN)。假设新增数字3

```javascript
const list = [0, 2, 7, 5, 12, 22, 17, 25, 19, 36, 99, 23, 28, 46, 92];
// 假设删除根节点，插入新数23到根节点，此时不符合最小堆的情况， 需要调整
const length = list.length - 1
function shiftUp (i){
  // 检查下标i的数据是否符合最小堆的规则
  let flag= 0;

  while(i>0 && !flag) {
    let middleIndex = parseInt(i/2)
    if (middleIndex > 0 && list[i] < list[middleIndex]){
      switchList(i, middleIndex)
      i = middleIndex
    } else {
      flag = 1
    }
  }
}
function switchList (x, y) {
  let num = list[x]
  list[x] = list[y]
  list[y] = num
}
list[length + 1] = 3
shiftUp(length+1)
console.log(list)
// 结果 [0, 2, 7, 3, 12, 22, 17, 5, 19, 36, 99, 23, 28, 46, 92, 25]
```

##### 接下来是很重要的一点： 如何搭建堆！

可以从空的堆开始，一次往堆中插入每一个元素，因为插入第i个元素花费的时间为O(log i),所以插入所有元素的时间为O(N(logN))。代码如下

```js
let n = 0
for(let i = 1; i< m; i++) {
  n++
  h[n] = a[i]
  siftUp(i)
}
```

其实还有更快的方式建立堆：
直接把99、5、36、7、22、17、46、12、2、19、25、28、1和92这14个数放入一个完全二叉树，（实际还是用数组存储）

![图](./Imgs/7_3_3.png)

在这个完全二叉树中，我们从最后一个节点开始，找出最后的子树一次排序，但是已知叶节点已经没有子节点，符合堆的特性，所以从最后一个非叶节点遍历查找，已知公式最后一个非叶节点是第n/2个结点。

逐个扫描所有节点，虽然看起来复杂，其实代码很简单:
```js
for(let i = parseInt(n/2); i>0; i--) {
  siftDown(i)
}
```
用这个方法建立堆的时间复杂度只有O(N).

> 堆还有一个作用，就是**堆排序**, 与快速排序一样，堆排序的时间复杂度也是O(N logN)

堆排序的实现原理很简单，假设建立的是最小堆，

```js
// 删除最大的元素
function deleteMax () {
  let t = h[1]; // 用一个临时变量记录堆顶点的值
  h[1] = h[n]; // 将堆的最后一个数放置顶点，
  n--; // 堆少一个数
  siftDown(1) // 向下调整
  return t
}

```

建堆以及堆排序的完整代码：
```js

// 假设读入的数据为 用来存放堆的数组
let h = [0, 99, 5, 36, 7, 22, 17, 46, 12, 2, 19, 25, 28, 1, 92 ]
let n = 14 // 堆的大小

// 交换函数
function switchList (x, y) {
  let num = h[x]
  h[x] = h[y]
  h[y] = num
}
// 删除最大的元素
function deleteMax () {
  let t = h[1]; // 用一个临时变量记录堆顶点的值
  h[1] = h[n]; // 将堆的最后一个数放置顶点，
  n--; // 堆少一个数
  siftDown(1) // 向下调整
  return t
}
//建立堆的函数
function createHeap () {
  // 从最后一个非叶子节点依次向上调整
  for(let i = parseInt(n/2); i>0; i--) {
    siftDown(i)
  }
}
// 向下调整函数
function siftDown (i){
  // 检查下标i的数据是否符合最小堆的规则
  let flag= 0;
  const length = h.length
  while(i*2<length && !flag) {
    let t = i;
    if (h[i] >h[i*2]) {
      t = i*2
    }
    if (((i*2 + 1)<=length) && (h[t] >h[i*2 +1])) {
      t = i*2 +1
    }
    if (t !== i ) {
      switchList(i, t)
      i = t
    } else {
      flag = 1
    }
  }
}

function main () {

  // 建堆
  createHeap()
  console.log('排序后', h)
  // 删除顶部元素，连续删除n次， 其实也就是从大到小把数拿出来。
  const length = h.length
  for (let i = 1; i < length; i++) {
    console.log(deleteMax())
  }
}
console.log('初始化', h)
main()


```





