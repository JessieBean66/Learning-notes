通过IP地址来查找IP归属地的功能，不知道你有没有用过？没用过也没关系，你现在可以打开百度，在搜索框里随便输一个IP地址，就会看到它的归属地

这个功能并不复杂，它是通过`维护一个很大的IP地址库`来实现的。地址库中包括IP地址范围和归属地的对应关系。

当我们想要查询202.102.133.13这个IP地址的归属地时，我们就在地址库中搜索，发现这个IP地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个IP地址范围对应的归属地“山东东营市”显示给用户了。

上一节我讲了二分查找的原理，并且介绍了最简单的一种二分查找的代码实现。今天我们来讲几种二分查找的变形问题。

不知道你有没有听过这样一个说法：“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有Bug的二分查找并不容易。

以下介绍几个比较经典的二分查找的变形问题:


?> **4种常见的二分查找变形问题**：
- `查找第一个 值等于给定值的元素`
- `查找最后一个 值等于给定值的元素`
- `查找第一个 大于等于给定值的元素`
- `查找最后一个 小于等于给定值的元素`


今天的内容，我都以数据是`从小到大`排列`为前提`，如果你要处理的数据是从大到小排列的，解决思路也是一样的。同时，我希望你最好先自己动手试着写一下这4个变形问题，然后再看我的讲述，这样你就会对我说的“二分查找比较难写”有更加深的体会了。



### 变体一：查找第一个值等于给定值的元素

| 数组下标 |  0  |   1  |  2 |  3  |  4  |  5  |  6  |  7  |  8   |  9   |
| - | - | - | - | - | - | - | - | - | - | - |
| 数组数值 | `1` | `3` | `4` | `5` | `6` | `8` | `8` | `8` | `11` |  `18`|


上一节课讲的二分查找的代码实现，首先拿`8`与区间的中间值`a[4]`比较，8比6大，于是在下标5到9之间继续查找。下标5和9的中间位置是下标7，a[7]正好等于8，所以代码就返回了。

尽管`a[7]`也等于`8`，但它并不是我们想要找的第一个等于8的元素，因为第一个值等于8的元素是数组下标为5的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。

~~~ java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid = low + ((high - low) >> 1);
    if (a[mid] >= value) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
  }

  if (low < n && a[low]==value) return low;
  else return -1;
}

// 换了一种实现方法，你看看是不是更容易理解呢？

public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != value)) return mid;
      else high = mid - 1;
    }
  }
  return -1;
}
~~~

解释一下这段代码。`a[mid]`跟要查找的`value`的大小关系有三种情况：大于、小于、等于。对于`a[mid] > value`的情况，我们需要更新`high = mid-1`；对于`a[mid] < value`的情况，我们需要更新`low = mid+1`。这两点都很好理解。那当`a[mid]=value`的时候应该如何处理呢？

如果我们查找的是任意一个值等于给定值的元素，当`a[mid]`等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当a[mid]等于要查找的值时，我们就需要确认一下这个`a[mid]是不是第一个`值等于给定值的元素。

我们重点看第11行代码。如果mid等于0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果mid不等于0，但a[mid]的前一个元素a[mid-1]不等于value，那也说明a[mid]就是我们要找的第一个值等于给定值的元素。

如果经过检查之后发现a[mid]前面的一个元素a[mid-1]也等于value，那说明此时的a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。

对比上面的两段代码，是不是下面那种更好理解？实际上，很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法。而对于我们做工程开发的人来说，代码易读懂、没Bug，其实更重要，所以我觉得第二种写法更好。


### 变体二：查找`最后一个`值等于给定值的元素

如果掌握了前面的写法，那这个问题你应该很轻松就能解决。
~~~ java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] != value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
~~~

重点看第11行代码。如果`a[mid]`这个元素已经是数组中的`最后一个`元素了，那它肯定是我们要找的；如果`a[mid]`的后一个元素`a[mid+1]`不等于value，那也说明`a[mid]`就是我们要找的最后一个值等于给定值的元素。

如果我们经过检查之后，发现`a[mid]`后面的一个元素`a[mid+1]`也等于value，那说明当前的这个`a[mid]`并不是最后一个值等于给定值的元素。我们就更新`low=mid+1`，因为要找的元素肯定出现在`[mid+1, high]`之间。




### 变体三：查找第一个`大于等于`给定值的元素

~~~ java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid - 1] < value)) return mid;
      else high = mid - 1;
    } else {
      low = mid + 1;
    }
  }
  return -1;
}
~~~


### 变体四：查找最后一个`小于等于`给定值的元素

~~~ java
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low > high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] <= value) {
      high = mid - 1;
    } else {
      if ((mid == n-1) || (a[mid + 1] > value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
~~~


### 解答开篇

如何快速定位出一个IP地址的归属地？

如果IP区间与归属地的对应关系不经常更新，我们可以先预处理这12万条数据，让其按照起始IP`从小到大排序`。如何来排序呢？我们知道，IP地址可以转化为32位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。

然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。


### 内容小结

凡是用二分查找能解决的，绝大部分我们更倾向于用`散列表`或者`二叉查找树`。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？

实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。

这些容易出错的细节有：`终止条件`、`区间上下界更新方法`、`返回值选择`。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出Bug free代码，会很有帮助。
