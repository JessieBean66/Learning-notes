散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是O(1)。`既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？`

带着这些问题，我们就来学习今天的内容，二叉查找树！

---------------

#### 二叉查找树（Binary Search Tree）

二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅`支持快速查找一个数据，还支持快速插入、删除一个数据`。它是怎么做到这些的呢？

这些都依赖于二叉查找树的特殊结构。**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**


##### 1.二叉查找树的查找操作

首先，我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。

代码实现了一下

~~~ javascript
class BinarySearchTree {
 
  this.tree;

  function find(data) {
    let p = tree;
    while (p != null) {
      if (data < p.data) p = p.left;
      else if (data > p.data) p = p.right;
      else return p;
    }
    return null;
  }

  class Node {
     /*
      节点结构：
      node: {
        data: '',
        left: node,
        right: node
      }
      */
    constructor (data) {
      this.data = data;
      this.left = null // 存储node对象
      this.right = null // 存储node对象
    }
  }
}

~~~



##### 2.二叉查找树的插入操作

二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。

如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。


~~~ javascript
function insert(data) {
  if (this.tree == null) {
    this.tree = new Node(data);
    return;
  }

  let p = tree;
  while (p != null) {
    if (data > p.data) {
      if (p.right == null) {
        p.right = new Node(data);
        return;
      }
      p = p.right;
    } else { // data < p.data
      if (p.left == null) {
        p.left = new Node(data);
        return;
      }
      p = p.left;
    }
  }
}
~~~

##### 3.二叉查找树的删除操作

针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。

- 第一种情况是，如果要删除的节点`没有子节点`，我们只需要直接将父节点中，指向要删除节点的指针置为null。比如图中的删除节点55。

- 第二种情况是，如果要删除的节点`只有一个子节点`（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。

- 第三种情况是，如果要删除的节点`有两个子节点`，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18。

关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。


##### 4.二叉查找树的其他操作

支持**快速地查找最大节点和最小节点、前驱节点和后继节点**

还有一个重要的特性，就是**中序遍历二叉查找树**，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。



#### 支持重复数据的二叉查找树













