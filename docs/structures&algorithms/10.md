
给定一个用户ID，如何查找这个用户的“最终推荐人”？ 带着这个问题，我们来学习今天的内容，递归（Recursion）！

#### 如何理解“递归”？

作者 个人觉得，有两个最难理解的知识点，一个是`动态规划`，另一个就是`递归`。

递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如DFS深度优先搜索、前中后序二叉树遍历等等

基本上，所有的递归问题都可以用递推公式来表示。 我们用递推公式将它表示出来就是这样的：

    f(n)=f(n-1)+1 其中，f(1)=1
    
#### 递归需要满足的三个条件

1. 一个问题的解可以分解为几个子问题的解

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

3. 存在递归终止条件
    
#### 如何编写递归代码？

写递归代码最关键的是写出递推公式，找到终止条件，剩下将递推公式转化为代码就很简单了。

?> 总结： 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

!> 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

#### 递归代码要警惕堆栈溢出

编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？

在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果最大深度比较小，此方法可行，否则不是很实用。

#### 递归代码要警惕重复计算

除此之外，使用递归时还会出现重复计算的问题为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的f(k)。

当递归调用到f(k)时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

除了`堆栈溢出`、`重复计算`这两个常见的问题。递归代码还有很多别的问题。

在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在`空间复杂度`上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析`递归代码空间复杂度`时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是O(1)，而是O(n)。

#### 怎么将递归代码改写为非递归代码？

递归有利有弊，利是递归代码的`表达力很强`，写起来非常`简洁`；而弊就是`空间复杂度高`、`有堆栈溢出的风险`、存在`重复计算`、过多的函数调用会`耗时较多`等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。

改写看看：

    int f(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        return f(n-1) + f(n-2);
    }

    改成：
    public int f(int n) {
        if (n == 1) return 1;
        if (n == 2) return 2;
        
        // hasSolvedList可以理解成一个Map，key是n，value是f(n)
        if (hasSolvedList.containsKey(n)) {
            return hasSovledList.get(n);
        }
        
        int ret = f(n-1) + f(n-2);
        hasSovledList.put(n, ret);
        return ret;
    }

那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。

#### 解答开篇如何找到“最终推荐人”？

解决方案是这样的：

    long findRootReferrerId(long actorId) {
        Long referrerId = select referrer_id from [table] where actor_id = actorId;
        if (referrerId == null) return actorId;
        return findRootReferrerId(referrerId);
    }

不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。

- 第一，如果递归很`深`，可能会有`堆栈溢出`的问题。

- 第二，如果数据库里存在`脏数据`，我们还需要处理由此产生的无限递归问题。比如demo环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果A的推荐人是B，B的推荐人是C，C的推荐人是A，这样就会发生`死循环`。


第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测A-B-C-A这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。
