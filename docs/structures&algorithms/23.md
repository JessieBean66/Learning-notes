前面我们讲的都是线性表结构，栈、队列等等。今天我们讲一种非线性表结构，树。树这种数据结构比线性表的数据结构要复杂得多，内容也比较多，所以我会分四节来讲解。

| 章节  |    23   |   24    |   25  |   26  |
| -  |    -   |   -    |   -  |   -  |
| 内容  |    树，二叉树   |   二叉查找树    |   平衡二叉查找树、红黑树  |   递归树  |


思考题：`二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？`

-----

#### 树（Tree）

“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。

不用复习的基本概念： 父节点、子节点、兄弟节点、根节点、叶子结点或者叶结点（没有子节点）

关于“树”，还有三个比较相似的概念：`高度（Height）`、`深度（Depth）`、`层（Level）`。他们的定义如下：

- 节点的高度 = 节点到叶子节点的`最长路径`（边数）

- 节点的深度 = 根节点到该节点所经历的`边的个数`

- 节点的层度 = 节点的深度 `+ 1` 

- 树的高度 = 根节点的高度

![树概念的例图](./Imgs/23_1.png)


在我们的生活中，“高度”这个概念，其实就是从下往上度量，比如我们要度量第10层楼的高度、第13层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是0。

“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是0。

“层数”跟深度的计算类似，不过，计数起点是1，也就是说根节点的位于第1层。


#### 二叉树（Binary Tree）

最常用还是二叉树,顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是`左子节点`和`右子节点`。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。我画的这几个都是二叉树。以此类推，你可以想象一下四叉树、八叉树长什么样子。

叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作`满二叉树`。

叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作`完全二叉树`。

> 那我们为什么还要特意把它拎出来讲呢？为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？


要理解完全二叉树定义的由来，我们需要先了解，**如何表示（或者存储）一棵二叉树**？

想要存储一棵二叉树，我们有两种方法，

1. **一种是基于指针或者引用的二叉链式存储法**，

2. **一种是基于数组的顺序存储法**。


先来看比较简单、直观的`链式存储法`。

![二叉树-链式存储法例图](./Imgs/23_2.png)

从图中你应该可以很清楚地看到，每个节点有`三个字段`，其中一个**存储数据**，另外两个是指向**左右子节点**的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。

再来看，基于数组的`顺序存储法`。

![二叉树-顺序存储法例图](./Imgs/23_3.png)

我们把根节点存储在下标`i = 1`的位置，那左子节点存储在下标`2 * i = 2`的位置，右子节点存储在`2 * i + 1 = 3`的位置。以此类推，B节点的左子节点存储在`2 * i = 2 * 2 = 4`的位置，右子节点存储在`2 * i + 1 = 2 * 2 + 1 = 5`的位置。

反过来，下标为`i/2`的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为1的位置），这样就可以通过下标计算，把整棵树都串起来。

不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“**浪费**”了一个下标为`0`的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。

换个例子，当二叉树存在多个节点没有右子节点的情况，存储在数组结构中会出现许多不规律的存储位置浪费的情况。

所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是**最节省内存**的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，`也是为什么完全二叉树要求最后一层的子节点都靠左的原因`。


#### 二叉树的遍历

经典的方法有三种，**前序遍历**、**中序遍历**和**后序遍历**。

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。


![二叉树-遍历方式例图](./Imgs/23_4.png)


**实际上，二叉树的前、中、后序遍历就是一个递归的过程**。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。

写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题A，就假设子问题B、C已经解决，然后再来看如何利用B、C来解决A。所以，我们可以把前、中、后序遍历的递推公式都写出来。


~~~ javascript
// 前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

// 中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

// 后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

~~~

用js模拟三种遍历方式
~~~ javascript
function preOrder(root) {
  if (root == null) return;
  console.log(root) // 此处为伪代码，表示打印root节点
  preOrder(root.left);
  preOrder(root.right);
}

function inOrder(root) {
  if (root == null) return;
  inOrder(root.left);
  console.log(root) // 此处为伪代码，表示打印root节点
  inOrder(root.right);
}

function postOrder(root) {
  if (root == null) return;
  postOrder(root.left);
  postOrder(root.right);
  console.log(root)  // 此处为伪代码，表示打印root节点
}
~~~

**二叉树遍历的时间复杂度是多少吗？**前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数`n`成正比，也就是说二叉树遍历的时间复杂度是`O(n)`。


#### 解答开篇&内容小结

讲了一种非线性表数据结构，树。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。

我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。

二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是O(n)，你需要理解并能用递归代码来实现。


















