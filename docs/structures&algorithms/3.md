数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。

**复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。**

### 为什么需要复杂度分析？

**事后统计法**: 把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。`这种统计方法有非常大的局限性。`

1. **测试结果非常依赖测试环境**

测试环境中硬件的不同会对测试结果有很大的影响。比如分别用Intel Core i9处理器和Intel Core i3处理器来运行。

2. **测试结果受数据规模的影响很大**

有序和无序数据的执行时间差距就很大  
**我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法**。这就是我们今天要讲的`时间、空间复杂度`分析方法。




### 大O复杂度表示法
算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？

~~~ java
// 例子1
int cal(int n) {
int sum = 0;
int i = 1;
for (; i <= n; ++i) {
    sum = sum + i;
}
return sum;
}
 ~~~

从CPU的角度来看，这段代码的每一行都执行着类似的操作：`读数据-运算-写数据`。尽管每行代码对应的CPU执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为`unit_time`。在这个假设的基础之上，这段代码的总执行时间是多少呢？

第2、3行代码分别需要1个unit_time的执行时间，第4、5行都运行了n遍，所以需要2n*unit_time的执行时间，所以这段代码总的执行时间就是(2n+2)*unit_time。可以看出来，**所有代码的执行时间T(n)与每行代码的执行次数成正比**。

~~~ java
int cal(int n) {
int sum = 0;
int i = 1;
int j = 1;
for (; i <= n; ++i) {
    j = 1;
    for (; j <= n; ++j) {
        sum = sum +  i * j;
        }
    }
}
~~~

段代码的总执行时间T(n)是多少呢？

第2、3、4行代码，每行都需要1个unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n * unit_time的执行时间，第7、8行代码循环执行了n2遍，所以需要2n2 * unit_time的执行时间。所以，整段代码总的执行时间T(n) = (2n2+2n+3)*unit_time。

尽管我们不知道unit_time的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，`所有代码的执行时间T(n)与每行代码的执行次数n成正比。`

?> 大O复杂度表示法：  **`T(n) = O(f(n))`**

T(n)是代码执行的时间，n表示数据规模的大小，f(n)表示每行代码执行的次数总和。

因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表`示代码执行时间随数据规模增长的变化趋势`，所以，也叫作`渐进时间复杂度`（asymptotic time complexity），简称**时间复杂度**。

当n很大时，你可以把它想象成10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大O表示法表示刚讲的那两段代码的时间复杂度，就可以记为：`T(n) = O(n)； T(n) = O(n^2)`。




### 时间复杂度分析

1. **只关注循环执行次数最多的一段代码**

大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，**我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了**。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。

2. **加法法则：总复杂度等于量级最大的那段代码的复杂度**

总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：

如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3. **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

上面讲了一个复杂度分析中的加法法则，这儿还有一个乘法法则。

如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

也就是说，假设T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环


【归并排序、快速排序的时间复杂度都是O(nlogn)】




### 几种常见时间复杂度实例分析

![复杂度量级](./Imgs/3_1.png)

对于上图的复杂度量级，基本涵盖了可以接触的所有代码的复杂度量级。我们可以粗略地分为两类，`多项式量级`和`非多项式量级`。其中，非多项式量级只有两个：`O(2^n)`和`O(n!)`。

当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于NP时间复杂度我就不展开讲了。我们主要来看几种常见的**多项式时间复杂度**。

1. **O(1)**

首先必须明确一个概念，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是O(1），而不是O(3)。

只要代码的执行时间不随n的增大而增长，这样代码的时间复杂度我们都记作O(1)。或者说，**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。**

2. **O(logn)、O(nlogn)**

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。

    i=1;
    while (i <= n)  {
        i = i * 2;
    }

第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。

从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2。当大于n时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量i的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：

    2^0 + 2^1 +  2^2 +  2^3 +  2^4 + ....... +  2^x  =  n

通过2x=n求解x这个问题我们想高中应该就学过了，我就不多说了。`x = log2n`，所以，这段代码的时间复杂度就是`O(log2n)`。

2^x=n求解x，得 x=log2n，所以，这段代码的时间复杂度就是O(log2n)。

3^x=n求解x，得 x=log3n 

    i=1;
    while (i <= n)  {
        i = i * 3;
    }

根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为`O(log3n)`。

实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为`O(logn)`。为什么呢？

我们知道，对数之间是可以互相转换的，log3n就等于log3^2 * log2^n，所以O(log3n) = O(C * log2n)，其中C=log3^2是一个常量。基于我们前面的一个理论：在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，`统一表示为O(logn)`。


3. **O(m+n)、O(m*n)**

代码的复杂度由两个数据的规模来决定

m和n是表示两个数据规模。当无法事先评估m和n谁的量级大，在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以存在时间复杂度就是O(m+n)。

需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。


### 空间复杂度分析

时间复杂度的全称是`渐进时间复杂度`，表示**算法的执行时间与数据规模之间的增长关系**。类比一下，空间复杂度全称就是`渐进空间复杂度`（asymptotic space complexity），表示**算法的存储空间与数据规模之间的增长关系**。


常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。


### 内容小结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。
![复杂度轴线图](./Imgs/3_2.png)
