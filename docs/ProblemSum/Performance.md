> 从输入 URL 到页面加载完成，发生了什么？

1. 首先我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，
2. 然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接
3. 随后我们向服务端抛出我们的 HTTP 请求,
4. 服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端
5. 拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作

#### 从流程步骤入手，抛出优化问题

- DNS 解析花时间，能不能尽量减少解析次数或者把解析前置？

能——浏览器 DNS 缓存和 DNS prefetch.

- TCP 每次的三次握手都急死人，有没有解决方案？

有——长连接、预连接、接入 SPDY 协议。
两个过程的优化往往需要我们和团队的服务端工程师协作完成

> 前端可做的优化

1. 减少请求次数和减小请求体积
2. 服务器越远，一次请求就越慢，部署时可把静态资源放在离我们更近的 CDN 上。【网络层面的性能优化】
3. 资源加载优化、服务端渲染、浏览器缓存机制的利用、DOM 树的构建、网页排版和渲染过程、回流与重绘的考量、DOM 操作的合理规避等等【浏览器端的性能优化】



#### webpack 优化方案

###### 构建过程提速策略：不要让 loader 做太多事情——以 babel-loader 为例

###### 不要放过第三方库

以 node_modules 为代表，它们庞大得可怕，却又不可或缺。



#### 浏览器缓存机制

> 强缓存

强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。

浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

 expires 存的是过期时间，（兼容方案），为避免浏览器端和服务器端时间不一致，可以采用 cache-control （新方案）里面的max-age 字段也允许我们通过设定相对的时间（秒）长度来达到同样的目的

Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。

Cache-Control 的神通，可不止于这一个小小的 max-age，还有 s-maxage 。这个 s-maxage 不像 max-age 一样为大家所熟知。的确，在项目不是特别大的场景下，max-age 足够用了。但在依赖各种代理的大型架构中，我们不得不考虑代理服务器的缓存问题。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的，并只对 public 缓存有效。

s-maxage 优先级高于 max-age，两者同时出现时，优先考虑 s-maxage。如果 s-maxage 未过期，则向代理服务器请求其缓存内容。

- public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。

  如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值。但多数情况下，public 并不需要我们手动设置。

- no-store与no-cache

  no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。

  no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

> 协商缓存：浏览器与服务器合作之下的缓存策略

协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源（304）。

协商缓存的实现：从 Last-Modified 到 Etag

Last-Modified最近一次修改的时间戳

Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，因此 Etag 能够精准地感知文件的变化。解决上一个方案存在时间过短或者文本实际没有变化的情况

Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。

> MemoryCache

MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

那么哪些文件会被放入内存呢？

事实上，这个划分规则，一直以来是没有定论的。不过想想也可以理解，内存是有限的，很多时候需要先考虑即时呈现的内存余量，再根据具体的情况决定分配给内存和磁盘的资源量的比重——资源存放的位置具有一定的随机性。

> Service Worker Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

大家注意 Server Worker 对协议是有要求的，必须以 https 协议为前提。


> Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。


#### 本地存储 -  cookie、webStorage、indexedDB

Cookie: 并非用来存储数据，而是存储状态，场景： 告知服务器 ‘我是我’。

Cookie 说白了就是一个存储在浏览器里的一个小小的文本文件，它附着在 HTTP 请求上，在浏览器和服务器之间“飞来飞去”。它可以携带用户信息，当服务器检查 Cookie 的时候，便可以获取到客户端的状态。

Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。

过量的 Cookie 会带来巨大的性能浪费。Cookie 是紧跟域名的。我们通过响应头里的 Set-Cookie 指定要存储的 Cookie 值。默认情况下，domain 被设置为设置 Cookie 页面的主机名，我们也可以手动设置 domain 的值：

```
Set-Cookie: name=xiuyan; domain=xiuyan.me
```

同一个域名下的所有请求，都会携带 Cookie。Cookie 虽然小，请求却可以有很多，随着请求的叠加，这样的不必要的 Cookie 带来的开销将是无法想象的。

Web Storage 的特性

  存储容量大： Web Storage 根据浏览器的不同，存储容量可以达到 5-10M 之间。

  仅位于浏览器端，不与服务端发生通信。

考虑到 Local Storage 的特点之一是持久，有时我们更倾向于用它来存储一些内容稳定的资源。比如图片内容丰富的电商网站会用它来存储 Base64 格式的图片字符串

##### 终极形态：IndexedDB

IndexedDB 是一个运行在浏览器上的非关系型数据库。既然是数据库了，那就不是 5M、10M 这样小打小闹级别了(不小于250M)。它不仅可以存储字符串，还可以存储二进制数据。

查看MDN，还有相对应更容易上手的indexedDB封装工具使用


#### CDN 的缓存与回源机制解析

CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。

CDN 的核心点有两个，一个是缓存，一个是回源。

##### CDN 优化细节

参考淘宝的网址  www.taobao.com， CDN的服务器的域名却是g.alicdn.com。
之前讲到 Cookie 的时候，Cookie 是紧跟域名的。同一个域名下的所有请求，都会携带 Cookie。而静态资源往往并不需要 Cookie 携带什么认证信息。把静态资源和主页面置于不同的域名下，完美地避免了不必要的 Cookie 的出现！以电商网站静态资源的流量之庞大，如果没把这个多余的 Cookie 拿下来，不仅用户体验会大打折扣，每年因性能浪费带来的经济开销也将是一个非常恐怖的数字。



#### 服务端渲染（SSR）的探索与实践

##### 先从客户端渲染说起

页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。跟节点下的内容是什么，该需要相应的js跑过后才得到。这就是客户端渲染

##### 服务端渲染

由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。

##### 服务端渲染解决了什么性能问题

事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。主要便利SEO 如搜索引擎爬虫获取关键词等
其次，性能方面： 解决了首屏加载速度过慢的问题。

##### 服务端渲染的应用实例

假设用express搭建后端node服务， Vue SSR 指南 中官方给出的例子为大家讲解 Vue 中SSR的实现思路。

与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。

##### 服务端渲染的应用场景

经常访问的那些网页看一看，会发现仍然有许多网站压根儿不用服务端渲染。因为相比较于浏览器的数量，服务器的数量稀少而宝贵。与其惦记服务器渲染，首屏渲染体验和 SEO 的优化方案这种低成本大招更优先。


#### 解锁浏览器背后的运行机制

##### 浏览器的‘心’---内核

不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。

浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。随着 JS 引擎越来越独立，内核也成了渲染引擎的代称。

> 渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。

> 目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。


##### 第一个可转化为代码的优化点——CSS 样式表规则的优化！

- 不做无用功：基于渲染流程的 CSS 优化建议

  CSS 引擎查找样式表，对每条规则都按从右到左的顺序去匹配。

HTML、CSS 和 JS，都具有阻塞渲染的特性。


css阻塞-> 网页不管dom解析完成没有，必须等cssom也完成后才渲染网页。也是为了避免HTML 页面丑陋地“裸奔”在用户眼前。

JS 的阻塞-》JS 的作用在于修改，本质上都是对 DOM 和 CSSDOM 进行修改。因此 JS 的执行会阻止 CSSOM，在我们不作显式声明的情况下，它也会阻塞 DOM。

JS的三种加载方式：
1. 正常模式：  `<script src="index.js"></script>`
2. async 模式：   `<script async src="index.js"></script>`
  async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。
3. defer 模式：  ` <script defer src="index.js"></script>`
  defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。


#### DOM 优化原理与基本实践

DOM 为什么这么慢? --> 因为收了“过路费”

> 把 DOM 和 JavaScript 各自想象成一个岛屿，它们之间用收费桥梁连接。——《高性能 JavaScript》

DOM 操作并非 JS 一个人的独舞，而是两个模块之间的协作。

##### 对 DOM 的修改引发样式的更迭

每操作一次 DOM（不管是为了修改还是仅仅为了访问其值），都要过一次“桥”。过“桥”的次数一多，就会产生比较明显的性能问题。因此“减少 DOM 操作”的建议，并非空穴来风。

对 DOM 的操作都不会局限于访问，而是为了修改它。当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发回流或重绘。

这个过程本质上还是因为我们对 DOM 的修改触发了渲染树（Render Tree）的变化所导致的

- 回流(重排)：涉及除本dom元素外的其他元素，都需要重新计算并绘制
- 重绘： 只改变了当前dom元素的样式修改，并不涉及尺寸几何属性的变化。


重绘不一定导致回流，回流一定会导致重绘。我们在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。

##### 提提速

案例：dom元素中添加10000句一样的话。

如果循环一万次，依次修改dom元素的innerhtml。过路费交太多了，必要的 DOM 更改太多了。考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。

这个思路，在 DOM Fragment 中体现得淋漓尽致。

> DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。

无论是字符串编辑还是DocumentFragment编辑，它们本质上都作为脱离了真实 DOM 树的容器出现，用于缓存批量化的 DOM 操作。

DOM Fragment 在维持性能的同时，保住我们代码的可拓展和可维护性。允许我们像操作真实 DOM 一样去调用各种各样的 DOM API，我们的代码质量因此得到了保证。


#### Event Loop 与异步更新策略

Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。


##### 前置知识：Event Loop 中的“渲染时机”

**Micro-Task 与 Macro-Task**

> 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。

- 常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。

- 常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。

##### 生产实践：异步更新策略

Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被批量触发。这就是异步更新。避免过度渲染，是上节提到的“让 JS 为 DOM 分压”的典范之一。


Vue状态更新手法：nextTick -> 更新操作给包装成一个异步操作派发出去



#### 回流（Reflow）与重绘（Repaint）

##### 如何规避回流与重绘

-  将“导火索”缓存起来，避免频繁改动
- 避免逐条改变样式，使用类名去合并样式
- 将 DOM “离线”

但是浏览器并没有那么简单， 比如谷歌浏览器缓存了一个 flush 队列，四次的元素几何修改，只触发了一次 Layout 和一次 Paint。除非达到了一定的时间间隔、特殊状态或者‘不得已’的时候，再将这些任务一口气出队。


还是需要懂优化原理，兼容那些‘不聪明’的浏览器


#### 优化首屏体验——Lazy-Load 初探

Lazy-Load，翻译过来是“懒加载”。它是针对图片加载时机的优化：在一些图片量比较大的网站（比如电商网站首页，或者团购网站、小游戏首页等），

通过元素的getBoundingClientRect() 方法来获取返回元素的大小及其相对于视口的位置。小于window.innerHeight，表示出现在视口内。


#### 事件的节流（throttle）与防抖（debounce）

熟练编写防抖和节流的写法，并清楚原理

目前比较流行的是用 Throttle 来优化 Debounce写法，避免一直防抖没有得到函数调用

```
// fn是我们需要包装的事件回调, delay是时间间隔的阈值
function throttle(fn, delay) {
  // last为上一次触发回调的时间, timer是定时器
  let last = 0, timer = null
  // 将throttle处理结果当作函数返回

  return function () {
    // 保留调用时的this上下文
    let context = this
    // 保留调用时传入的参数
    let args = arguments
    // 记录本次触发回调的时间
    let now = +new Date()

    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值
    if (now - last < delay) {
    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器
       clearTimeout(timer)
       timer = setTimeout(function () {
          last = now
          fn.apply(context, args)
        }, delay)
    } else {
        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应
        last = now
        fn.apply(context, args)
    }
  }
}

// 用新的throttle包装scroll的回调
const better_scroll = throttle(() => console.log('触发了滚动事件'), 1000)

document.addEventListener('scroll', better_scroll)
```




#### Performance、LightHouse 与性能 API

性能监测是前端性能优化的重要一环。监测的目的是为了确定性能瓶颈，从而有的放矢地开展具体的优化工作。

平时我们比较推崇的性能监测方案主要有两种：**可视化方案、可编程方案**。

##### 可视化监测：从 Performance 面板说起

Performance 是 Chrome 提供给我们的开发者工具，用于记录和分析我们的应用在运行时的所有活动。它呈现的数据具有实时性、多维度的特点，可以帮助我们很好地定位性能问题。

我们看右上角的三个栏目：FPS、CPU 和 NET。

**FPS**：这是一个和动画性能密切相关的指标，它表示每一秒的帧数。图中绿色柱状越高表示帧率越高，体验就越流畅。若出现红色块，则代表长时间帧，很可能会出现卡顿。图中以绿色为主，偶尔出现红块，说明网页性能并不糟糕，但仍有可优化的空间。

**CPU**：表示CPU的使用情况，不同的颜色片段代表着消耗CPU资源的不同事件类型。这部分的图像和下文详情面板中的Summary内容有对应关系，我们可以结合这两者挖掘性能瓶颈。

**NET**：粗略的展示了各请求的耗时与前后顺序。这个指标一般来说帮助不大。

##### 挖掘性能瓶颈

先看 CPU 图表和 Summary 饼图。CPU 图表中，我们可以根据颜色填充的饱满程度，确定 CPU 的忙闲，进而了解该页面的总的任务量。而 Summary 饼图则以一种直观的方式告诉了我们，哪个类型的任务最耗时（从本例来看是脚本执行过程）。这样我们在优化的时候，就可以抓到“主要矛盾”，进而有的放矢地开展后续的工作了。

再看 Main 提供给我们的火焰图。这个火焰图非常关键，它展示了整个运行时主进程所做的每一件事情（包括加载、脚本运行、渲染、布局、绘制等）。x 轴表示随时间的记录。每个长条就代表一个活动。更宽的条形意味着事件需要更长时间。y 轴表示调用堆栈，我们可以看到事件是相互堆叠的，上层的事件触发了下层的事件。

CPU 图标和 Summary 图都是按照“类型”给我们提供性能信息，而 Main 火焰图则将粒度细化到了每一个函数的调用。到底是从哪个过程开始出问题、是哪个函数拖了后腿、又是哪个事件触发了这个函数，这些具体的、细致的问题都将在 Main 火焰图中得到解答。

##### 可视化监测： 更加聪明的 LightHouse

程序员们许了个愿：如果工具能帮助我们把页面的问题也分析出来就好了！上帝听到了这个愿望，于是给了我们 LightHouse：

> Lighthouse 是一个开源的自动化工具，用于改进网络应用的质量。 你可以将其作为一个 Chrome 扩展程序运行，或从命令行运行。 为Lighthouse 提供一个需要审查的网址，它将针对此页面运行一连串的测试，然后生成一个有关页面性能的报告。

敲黑板划重点：它生成的是一个报告！Report！不是干巴巴地数据，而是一个通过测试与分析呈现出来的结果（它甚至会给你的页面跑一个分数出来）。这个东西看起来也真是太赞了，我们这就来体验一下！


##### 访问 performance 对象

performance 是一个全局对象。我们在控制台里输入 window.performance，就可一窥其全貌

**关键时间节点**  在 performance 的 timing 属性中，我们可以查看到如下的时间戳

```
const timing = window.performance.timing
// DNS查询耗时
timing.domainLookupEnd - timing.domainLookupStart

// TCP连接耗时
timing.connectEnd - timing.connectStart

// 内容加载耗时
timing.responseEnd - timing.requestStart

```

除了这些常见的耗时情况，我们更应该去关注一些关键性能指标：firstbyte、fpt、tti、ready 和 load 时间。这些指标数据与真实的用户体验息息相关，是我们日常业务性能监测中不可或缺的一部分

```
// firstbyte：首包时间
timing.responseStart – timing.domainLookupStart

// fpt：First Paint Time, 首次渲染时间 / 白屏时间
timing.responseEnd – timing.fetchStart

// tti：Time to Interact，首次可交互时间
timing.domInteractive – timing.fetchStart

// ready：HTML 加载完成时间，即 DOM 就位的时间
timing.domContentLoaded – timing.fetchStart

// load：页面完全加载时间
timing.loadEventStart – timing.fetchStart

```

以上这些通过 Performance API 获取到的时间信息都具有较高的准确度。我们可以对此进行一番格式处理之后上报给服务端，也可以基于此去制作相应的统计图表，从而实现更加精准、更加个性化的性能耗时统计。


通过访问 performance 的 memory 属性，我们还可以获取到内存占用相关的数据；通过对 performance 的其它属性方法的灵活运用，我们还可以把它耦合进业务里，实现更加多样化的性能监测需求——灵活，是可编程化方案最大的优点。



